# 第五组 大作业Part3报告
陈敬文 李子睿 刘云

## 实验过程

### 1. 环境配置
- **ALSA开发库** libasound2-dev, 用于音频播放
- **POSIX线程库** pthread, 通常内置于glibc
- **数学库** libm, 通常内置于glibc

在执行编译和目标机器上安装所需库. 因为编译时没有使用静态编译, 因此目标机器上也需要安装所需的库.
```bash
# 音频库安装
sudo apt install libasound2 libasound2-dev
```


### 2. 程序

#### 2.1. 程序结构
程序执行时, 主进程读取目录中所有wav文件, 并加入tracklist. 随后主进程创建UI线程, 控制线程. UI线程负责定时获取全局状态变量, 更新绘制用户界面. 控制线程负责捕获用户键盘操作, 并作出响应. 每播放一首歌曲时, 控制线程会建立新的播放线程, 当歌曲播放结束或被切歌时, 该播放线程会被终止. 因此任意时刻, 最多只有一个播放线程存在.

不同线程通过互斥锁和全局状态变量互相通讯.

#### 2.2. 上一曲下一曲
切歌过程由控制线程操作. 由于tracklist中不同文件的格式可能不同, 因此播放一首文件时, 控制线程会重新创建专属于该文件的播放线程. 在控制线程中初始化PCM, mixer等结构后, 会开启播放线程.

播放线程会循环读取wav文件, 存入buffer中, 并通过`snd_pcm_writei`将buffer内容写入声卡. 

由于播放线程涉及大量I/O操作, 以及获取互斥锁等操作全局变量的过程, 因此本次实现尽量避免控制线程直接通过`pthread_cancel`终止播放线程. 我们选择让播放线程自己终止自己. 如果控制线程希望结束播放线程, 播放线程会在关键操作结束后(如更新一次buffer后), 检查全局状态变量`exit_flag`. 如果满足条件, 则播放线程会终止自己. 

当用户按下`n`或`b`键后, 被控制线程捕获. 播放线程会首先修改`exit_flag`, 等待当前播放线程结束. 结束后释放PCM等资源. 随后根据用户操作, 初始化针对于上一曲或下一曲的资源, 并开启新的播放线程.

#### 2.3. 快进快退
快进快退是通过移动wav文件指针实现. 控制线程在捕获快进快退指令后, 根据wav文件头中`byte_rate`计算移动10s需要移动的文件指针字节数. 在检验指针位置合法性后(如不能超过文件头和超过文件尾), 使用`fseek`移动wav文件指针.

当先前buffer中内容播放完成后, 新写入buffer的内容为移动后的文件内容.

#### 2.4. 暂停继续
暂停继续操作不会关闭已有的播放线程. 暂停操作由控制线程操作`snd_pcm_pause`函数实现. 该函数会冻结播放缓冲区. 同时, 为了节约暂停时的资源, 控制线程同时修改`pause_flag`. 当播放线程检测到`pause_flag`暂停后, 会通过条件变量挂起. 当控制线程恢复播放时, 操作`snd_pcm_pause`后, 会通过条件变量重新唤醒播放线程.

#### 2.5. 多种倍速播放

本部分实现了基于WSOLA (Waveform Similarity Overlap-Add)的时域变速算法，主要用于音频变速不变调。下面详细说明其实现过程：


##### 2.5.1. 数据结构

* **WsolaConfig** ：配置参数，包括帧长（frame_size）、重叠长度（overlap_size）、变速比（speed_ratio）。
* **WsolaState** ：运行状态，包含当前帧、前一帧、输出缓冲、通道数、采样位数等。


##### 2.5.2. PCM与浮点转换

* `read_sample`：将 interleaved PCM 数据（16/24/32位）转换为 float，便于后续处理。
* `write_sample`：将 float 数据转换回 PCM 格式，写入输出缓冲。


##### 2.5.3. 寻找最佳重叠点

* `find_best_offset`：
  * 先用较大步长（coarse_step）粗略搜索，找到相关性最大的重叠起点；
  * 再在该点附近用步长1精细搜索，得到最佳重叠偏移（offset）。
  * 相关性通过重叠区的点乘计算，最大相关性即为最佳拼接点。


##### 2.5.4. 状态初始化

* `wsola_state_init`：
  * 分配当前帧、前一帧、输出缓冲的内存；
  * 前一帧初始化为全零，便于首帧处理。


##### 2.5.5. 变速处理主流程（核心）

* `wsola_state_process`：

  1. **参数准备** ：重置输入/输出索引，计算每次处理的chunk大小（frame_size - overlap_size）。
  2. **内存检查** ：如输出缓冲不够大则扩容。
  3. **分帧处理** ：

  * 将输入PCM数据分帧，转换为浮点，填入curr_frame。
  * 对每一帧：
    * 调用 `find_best_offset`，在prev_frame中寻找与curr_frame重叠区最相似的拼接点。
    * 计算输出起点 `ostart`（根据变速比调整）。
    * 将当前帧与前一帧的重叠部分相加，非重叠部分直接赋值，结果写入输出缓冲fout。
    * 更新prev_frame为curr_frame，推进输入/输出索引。

  1. **输出限制** ：如输出帧数超限则截断。
  2. **浮点转PCM** ：将fout中的浮点数据转换为PCM，写入out_bytes。
  3. **返回实际输出帧数** 。


##### 2.5.6. 资源释放

* `wsola_state_free`：释放所有分配的内存。


##### 2.5.7. 算法特点

* **WSOLA**的核心是“重叠-相似拼接”，通过寻找最佳重叠点，拼接时减少音质失真。
* 变速时，输出帧的间隔根据speed_ratio调整，实现变速不变调。
* 支持多通道和多种采样位宽。

### 2.6 日志

程序实现了完整的日志记录系统，负责记录用户操作和程序运行状态。日志系统采用多线程安全设计，使用互斥锁保护日志文件的并发访问。

日志内容分为四个级别：
- **用户操作(USER_OP)**：记录所有用户的按键操作及结果，包括播放控制、音量调节、快进快退、切歌等操作的成功或失败状态
- **信息(INFO)**：记录程序正常运行状态，如文件加载、线程启动、播放开始等关键节点
- **警告(WARNING)**：记录可恢复的异常情况，如声卡underrun、不支持的暂停功能等
- **错误(ERROR)**：记录严重错误，如文件打开失败、PCM初始化失败、格式不支持等

日志格式统一为：`[时间戳] [信息类型] 日志内容`。时间戳精确到秒，格式为`YYYY-MM-DD HH:MM:SS`。所有错误信息不在命令行显示，完全记录到日志文件`music_player.log`中，确保程序运行时界面的整洁性。

日志系统在程序启动时初始化，退出时自动关闭并记录关闭信息，支持多次运行的日志追加写入。

### 2.7 滤波器

程序实现了基于FIR滤波器的五频段音频均衡器,支持对低音、低中音、中音、高中音、高音五个频段进行独立调节。滤波器采用了窗函数法设计,使用汉明窗来减少频谱泄漏。

滤波器系统的核心是针对不同频段设计相应的滤波器类型。对于低音频段(60-250Hz),使用低通滤波器提取低频成分;对于高音频段(4000-16000Hz),采用高通滤波器突出高频部分;而对于三个中间频段,分别设计带通滤波器来分离对应的频率范围。每个频段的滤波器阶数设为16阶,在保证效果的同时兼顾运算效率。

FIR滤波器的实现采用了经典的卷积运算。每个滤波器维护一个延迟线数组,新的音频采样进入时,延迟线中的历史数据向后移动一位,然后与预计算的滤波器系数进行点乘累加得到输出。这种结构保证了滤波器的线性相位特性,不会引入相位失真。

均衡器提供了四种预设模式:平衡模式所有频段增益为0dB;低音增强模式对低频段施加16dB增益,高频段衰减16dB;高音增强模式则相反;人声增强模式突出中频范围并抑制两端频段。用户可以通过按键实时切换这些预设,也可以用'e'键开关整个均衡器功能。

音频处理时,程序将16位PCM数据转换为双精度浮点数进行计算,每个采样点经过五个频段滤波器并行处理后求和,最终限幅并转换回整型输出。这种并行处理架构确保了各频段互不干扰,同时保持了较好的音质表现。

### 3. 使用说明

#### 3.1 编译

```bash
$CC *.c -o music_app -lasound -lpthread -lm -O3 -ffast-math
```
其中`-lasound`动态链接ALSA音频库. `-lpthread`动态链接线程库. `-lm`动态链接数学库, 用于滤波器实现. `-O3`和`-ffast-math`用于加速倍速算法.

#### 3.2 使用

```bash
./music_app -m <dir_path>
```

运行后程序会自动读取目录下所有的wav文件, 并加入到tracklist. 用户可以通过 `ctrl+C`或 `q`键退出程序. 其他操作见用户界面提示.

## 实验结果

![结果图](./fig/result.png)

## 实验心得

### 单片机算力不足
TODO

### 线程保护

TODO

### 条件变量唤醒
在播放线程中用如下结构实现音乐暂停时播放线程的挂起.
```c
// play.c
pthread_mutex_lock(&mutex);
while (pause_flag && !exit_flag) {
    LOG_INFO("播放线程暂停");
    pthread_cond_wait(&cond, &mutex);
}
```
其中`pause_flag`作为全局变量, 用作控制线程和播放线程的通讯. 在读取和修改全局变量时, 必须获取`mutex`锁保证线程安全. `cond`作为条件变量, 仅仅用于唤醒等待`cond`变量的线程.
当播放线程获取`mutex`并进入while循环后, 在`pthread_cond_wait`中会释放`mutex`并等待`cond`条件. 当播放恢复, 控制线程修改`pause_flag`并通过`cond`唤醒播放线程. 此时播放线程会重新获取`mutex`锁, 并在while循环中互斥访问全局变量, 进而退出while循环继续执行播放指令.

## wav文件来源
https://samplelib.com/zh/sample-wav.html
TODO
